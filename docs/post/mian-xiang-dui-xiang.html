<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="## **思路**

> 学习思路：学习软件工程的面向对象有助于学习语言背后的设计思想。">
<meta property="og:title" content="面向对象">
<meta property="og:description" content="## **思路**

> 学习思路：学习软件工程的面向对象有助于学习语言背后的设计思想。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://membrane-s.github.io/post/mian-xiang-dui-xiang.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>面向对象</title>


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">面向对象</h1>
<div class="title-right">
    <a href="https://membrane-s.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/membrane-s/membrane-s.github.io/issues/1" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h2><strong>思路</strong></h2>
<blockquote>
<p>学习思路：学习软件工程的面向对象有助于学习语言背后的设计思想。 首先什么都不考虑让我们先来考虑一点关于该思路，（在学习时应深入到jvm）</p>
<p>什么是类？ 我们都晓得类有属性和方法，知道基本的构成之后，我们可以创建一个类。</p>
<p>那么我们有了一个类之后呢？ 可以根据这个类，来创建对象，创建对象即使对类的具体化，实例化，类似于数据库中的一行行数据。 以上两个问题都很简单，就是类的创建和对象的创建。</p>
<p>那么这里让我们先看看单个的类里，有什么样的设计</p>
<ol>
<li>对象的创建初始化</li>
<li>属性</li>
<li>方法</li>
<li>方法重载</li>
<li>final，static，this</li>
</ol>
<p>学习软件工程后能够明白，使用面向对象建模解决实际问题，不可能单单依赖于一个类，而是通过多个类的共同协作，最终解决问题。我们知道一个高内聚低耦合的设计是一个好的设计，那么在Java中是通过什么体现的？</p>
<p>我们知道面向对象有继承封装多态和抽象四个基本特性。</p>
<p>封装是什么？<strong>数据和方法包装进类中，以及具体实现的隐藏，常共同被称作是封装</strong>，对外只保留接口，对外提供服务即可，而无需其他模块了解该模块内部情况，最大程度的降低了模块间的耦合程度。</p>
<p>继承，提高了代码的重用性，那么在继承中又具体分为单继承和多继承，单继承很容易理解，但是我们知道，Java为了避免类似c++的多重状态继承那样复杂的问题，采用了多重类型继承即接口的继承。一个类可以实现多个接口，接口同样可以扩展其他接口。</p>
<p>多态和继承是相生的，继承(is-a)的关系就意味着父类引用可以指向子类对象，那么既然强调了这一点，就说明自然有妙用，多态便是在这一步的基础上开展的，其中又设计到方法覆盖（Override），动态绑定，通过提高一定的抽象性，而省去编写大量重复的代码。</p>
<p>抽象也是OOD很重要的一个方面，抽象主要体现在抽象类和接口中，抽象类是为了继承而生的，是由子类具有相同的一类特征抽象而来，也可以说是其基类或父类。为什么这样说，因为抽象类的初衷是<code class="notranslate">抽象</code>,即规定这个类的型，具体实现还不确定，是不完整的，故也不允许直接创建实例。Java编程语言支持类型的多重继承，这是一个类实现多个接口的能力。一个对象可以有多种类型：他自己的类的类型和类所实现的所有接口的类型。这意味着如果一个变量被声明为接口的类型，那么它的值可以引用任何实现了接口的类的实例化的对象。与实现的多重继承一样，一个类可以继承它所扩展的接口中定义的方法的不同实现。</p>
</blockquote>
<h2><strong>我们需要了解的背景：</strong></h2>
<p>面向对象并不是突然出现，然后取代了传统范型的。在20世纪70年代和80年代期间，模块化理论经历了稳定的发展，而对象只是模块化理论中的衍变发展。如果不理解为什么面向对象范型比传统方法范型更优秀，就很难正确的使用对象。为了做到这一点，意识到<code class="notranslate">objects were simply an evolutionary development within the theory of modularity</code>。</p>
<p>当一个巨大的项目由单独的代码模块组成时，想一下当一个由十万行代码组成的项目里只有一个文件，那么无论是调试，或者阅读都将是一场噩梦。</p>
<p>解决方法就是将该产品分成较小的块，称之为模块。</p>
<p>那么什么是模块呢？</p>
<ol>
<li><code class="notranslate">a set of one or more contiguous program statements having a name by which other parts of the system can invoke it ,and preferably having its own distinct set of variable names.</code></li>
<li><code class="notranslate">a module is a lexically contiguous sequence of program statements,bounded by boundary elements,having an aggregate identifier.</code></li>
</ol>
<p>模块是一个具有具有边界，标识符的词汇上连续的语句序列。</p>
<p><strong>传统范型的过程和函数都是模块。面向对象范型中，一个对象是模块，对象内的方法也是模块。并且使用模块内聚和耦合来形容模块内部交互的程度和模块间的交互程度。</strong></p>
<p>如何评价模块的质量：</p>
<ol>
<li>可重用性</li>
<li>可维护性</li>
</ol>
<blockquote>
<p>内聚</p>
<p><strong>模块的内聚是模块内部的情况，我们所说的高内聚，其实并不是说模块内越复杂越好，高内聚指的应该有两点，1.模块内部有多个操作 2.各操作独立性强</strong></p>
<p>简单来说，我们可以将模块想象为一个操场，而将内部的操作则为各个班级，每个班级应该独立，整齐的在一个地方，这就叫好的内聚，而如果没有任何纪律规定的解散，就是不好的内聚。</p>
<ul>
<li>信息性内聚
<ol>
<li>如果模块进行许多操作，每个都有各自的入口点，每个操作的代码相互独立，而且所有的操作都对相同的数据结构完成，则该模块具有信息性内聚。</li>
<li>信息性内聚的各操作是完全独立的</li>
</ol>
</li>
<li>功能性内聚
<ol>
<li>只执行一个操作或达到单一目的的模块叫做功能性内聚。很容易理解，这样的模块可重用，但是并不完全独立，因为他需要对数据进行操作，如果我们希望重用功能内聚的模块，那么必须重用他所操作的数据。</li>
<li>总而言之，不难理解，具有功能性内聚的模块进行维护更加的容易，并且可以隔离错误，重用性较高。</li>
</ol>
</li>
<li>通信性内聚
<ol>
<li>如果一个模块执行一系列产品要遵循的步骤顺序有关的操作，而且所有操作都对相同的数据进行，则该模块具有通信性内聚。</li>
<li>这样的模块中个操作是紧密相连的，但是不具有重用性。</li>
</ol>
</li>
<li>过程性内聚
<ol>
<li>若一个模块执行一系列与产品要遵循的步骤顺序有关的操作，则具有过程性内聚</li>
<li>操作之间是过程关联的，但是操纵间依然是弱连接，而且重用性依然不太行，解决方案就是再分子模块，每个模块执行一个操作。</li>
</ol>
</li>
<li>时间性内聚
<ol>
<li>当模块执行一系列与时间有关的操作时，该模块具有时间性内聚</li>
<li>特点
<ol>
<li>这个模块的操作之间的关联很弱，但与其他模块的操作却有很强的关联。</li>
</ol>
</li>
</ol>
</li>
<li>逻辑性内聚
<ol>
<li>当一个模块进行一系列相关的操作，每个操作由调用的模块来选择时（可理解为相关的东西被放在一起，但是乱糟糟的），该模块就具有逻辑性内聚</li>
<li>缺点
<ol>
<li>接口难以理解，造成模块整体上的不易理解。</li>
<li>完成多个操作的代码相互纠缠在一起，导致严重的维护问题，也很难重用这样的模块。</li>
</ol>
</li>
</ol>
</li>
<li>偶然性内聚
<ol>
<li>如果一个模块执行多个完全不相关的操作（可以理解为将完全不相干的东西放在一起），则具有偶然性内聚</li>
<li>缺点
<ol>
<li>偶然性内聚的模块化过程比不模块化更糟糕</li>
<li>这些模块是不可重用的</li>
</ol>
</li>
<li><strong>不可重用是一个严重的缺点，构建软件的成本很高，因此要尽可能的重用模块</strong>。</li>
</ol>
</li>
</ul>
<p>耦合</p>
<p>耦合指的是两个模块之间的交互程度。</p>
<p>我们说模块间低耦合，其实就是说的，模块之间的关联，不要枝枝叶叶的连在一起而只保留信息的传递。</p>
<ul>
<li>数据耦合</li>
<li>印记耦合</li>
<li>控制耦合
<ol>
<li>如果两个模块中的一个模块给另一个模块传递控制要素，则它们具有控制耦合。也就是说，一个模块明确地控制了另一个模块的逻辑。</li>
</ol>
</li>
<li>公用耦合</li>
<li>内容耦合
<ol>
<li>如果两个模块中的一个直接引用了另一个模块的内容，则它们之间是内容耦合</li>
<li>q和p内容耦合会导致当对其中一个进行修改时，另外一个模块也需要修改。</li>
</ol>
</li>
</ul>
</blockquote>
<p>相关迹象表明，耦合越强，出错的倾向就越大，这个现象背后的主要原因是代码内部的依赖性导致回归错误。模块间的耦合较强时，频繁的修改将不总是限定于有出错倾向的模块自身，通常修复一个错误需要调整多个模块。即：强耦合对维护性带来有害的影响。</p>
<p><strong>以上这么多的文字，就是为了告诉我们高内聚低耦合的模块是一个好的设计，当每个模块内部有最大的关联而模块之间有最小的关联时，不管是纠错性，完善性还是适应性的维护，维护的工作量都会减少。</strong></p>
<p><strong>那么这种设计如何实现呢？</strong></p>
<pre class="notranslate"><code class="notranslate">A major theme of this book is that two essential aspects of a product are its operations and the data on which the operations act. Therefore, the two basic ways of designing a product are operation-oriented design and data-oriented design. In  operation-oriented design , the emphasis is on the operations. An example is data flow analysis (Section 14.3), where the objective is to design modules with high cohesion (Section 7.2). In  data-oriented design,the data are considered first. For example, in Jackson’s technique (Section 14.5), the structure of the data is determined first, and then the procedures are designed to conform to the structure of the data.

A weakness of operation-oriented design techniques is that they concentrate on the operations; the data are of only secondary importance. Data-oriented design techniques similarly emphasize the data, to the detriment of the operations. The solution is to use object-oriented techniques, which give equal weight to operations and data. In this chapter,operation- and data-oriented design are described fi rst, and then object-oriented design.
Just as an object incorporates both operations and data, so object-oriented design combines features of operation-oriented and data-oriented design. Therefore, a basic understanding of operation- and data-oriented design is needed to get a full understanding of object-oriented design.Before specifi c design techniques are examined, some general remarks must be made regarding design.

面向操作设计集中于操作方面，数据是次要的，面向数据设计则集中于数据，低估了操作的作用。因此解决方法就是面向对象设计，他对操作和数据给予同样的重视。因为对象将数据和操作结合在一起，因此面向对象设计结合了面向操作和面向数据的特性。
面向对象设计（Object-Oriented Design,OOD）
</code></pre>
<p><strong>面向操作设计</strong></p>
<p>将一个产品分解成具有高内聚低耦合的模块。可以使用两个传统实用技术：数据流分析和事务分析。理论上，只要规格说明可以用一个数据流图表示，就可以应用数据流分析，而且每个产品可以使用DFD表示，数据流分析就普遍适用。</p>
<ul>
<li>数据流分析DFA
<ol>
<li>是一项得到具有高内聚模块的传统设计技术。一旦完成了DFD，软件设计者就有了关于产品设计和输出的精确和完整的信息。</li>
</ol>
</li>
<li>数据流分析扩展(不加介绍)</li>
</ul>
<p><strong>面向数据设计</strong></p>
<p>面向数据设计背后的基本原则是根据对其运行的数据结构设计产品。首先确定数据结构，然后赋予每个过程与它所操作的数据相同的结构。</p>
<p><strong>面向对象设计</strong></p>
<p>为什么叫做面向对象设计，因为对象中包含了数据和对数据进行的操作。综合了面向操作和面向数据的设计。</p>
<p>OOD的两个关键步骤是完成类图和进行详细设计。</p>
<ol>
<li>完成类图：
<ol>
<li>确定属性及其格式</li>
<li>给相关类分配方法
<ol>
<li>通过检查每个场景的交互图来确定产品的所有操作，这很简单。困难的部分是确定如何决定哪些方法应该与每个类相关联。</li>
<li>方法可以分配给类或者向该类的对象发送消息的客户端。</li>
<li>可以用于帮助决定如何分配操作的一个原则是信息隐藏。也就是说，类的状态变量应该被声明为private(只能在该类的对象中访问)或protected（只能在该类的对象或该类的子类中访问）因此对状态变量执行的操作必须是该类的本地操作。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>数据封装：一个模块中包含一个数据结构和对这个数据结构进行的操作。</p>
<p>抽象数据类型：是一个数据类型，连同对这种类型的实例进行的操作</p>
<p>信息隐藏：期中实现的细节对其他模块是隐藏的</p>
<p>对类的描述使抽象性发展到顶点，类是支持继承的一种抽象数据类型。对象是类的一个实例。</p>
<p>通过良好设计的对象，也就是具有高内聚和低耦合的对象可以对一个物理实体的所有方面进行建模，就是说，在一个现实世界实体和模拟他的对象之间有一个清楚的映像。</p>
<p>如何实现的细节被隐藏了，与一个对象进行通信的唯一途径就是给对象发送消息。因此，对象基本上是具有良好定义接口的独立单元，并且容易维护，比较安全，发生回归错误的机会也就少了。</p>
<h2><strong>对象和类是啥</strong></h2>
<p>对象是什么？</p>
<ul>
<li>对象就是OO程序的构建模块，使用OO技术的程序实际上是多个对象的集合。</li>
<li>对象数据：存储在一个对象中的数据表示对象的状态(属性)</li>
<li>对象的行为：就是对象能做什么，通过发送消息调用方法。</li>
</ul>
<p>类是什么？</p>
<ul>
<li>简单的说，类就是对象的一个蓝图。</li>
<li>实例化一个对象时，就是使用一个类作为构建这个对象的基础。</li>
<li>类的属性：由属性表示，每个类必须定义属性来存储由这个类实例化的各个对象状态。</li>
<li>方法：实现了一个类所需的行为。</li>
<li>消息：消息是对象之间的通信机制。例如当对象A调用对象B的一个方法时，对象A就是在向对象B发送一个消息，对象B的响应由其返回值定义。只有对象的公共方法(而不包括私有方法)能够由另一个对象调用。</li>
</ul>
<h2><strong>对象和类怎么使用</strong></h2>
<p>我们了解到类和对象的基本定义之后，来看看到底如何使用？</p>
<h2><strong>对象的创建和初始化</strong></h2>
<p><strong>在使用对象前，我们要创建一个类，我们要晓得，类是用来干嘛的？</strong></p>
<p>类是对象的抽象蓝图，是用来创建对象（集合数据和作用在数据上的操作于一体）的模板。<strong>那么如何类是如何设计的使其能够创建一个对象？</strong></p>
<p>说创建一个对象，其实就是对属性进行赋值。</p>
<p>c++引入了**构造器(constructor)**的概念，<strong>在创建对象时被自动调用的特殊方法</strong>。Java中也采用了构造器，并额外提供了“垃圾回收器”。通过构造器和关键字new，完成对对象的初始化和对象内存的分配。</p>
<p>语言层面上创建一个对象，通常仅仅是一个<code class="notranslate">new</code>关键字而已。</p>
<p>但是在虚拟机层面上，当虚拟机遇到一条字节码new指令时</p>
<ol>
<li>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化过，如果没有，那么必须先执行相应的类加载机制。</li>
<li>在类加载检查通过后，虚拟机就为新生对象分配内存。对象所需内存在类加载完成时便可完全确定。</li>
<li>内存分配完成之后，虚拟机必须将分配到的内存空间初始化为0值。</li>
</ol>
<p>完成上面的部分，其实创建对象才刚刚开始---构造函数，即Class文件中的<code class="notranslate">&lt;init&gt;()</code>方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也都没有按照预定的意图构造好。一般来说，new指令之后回接着执行<code class="notranslate">&lt;init&gt;()</code>方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
<p>而以上过程中的<code class="notranslate">&lt;init&gt;()</code>方法,就是类中的构造器方法。</p>
<p><strong>构造器使对象能够按照我们预定的意图构造好，那么这个方法应该如何设计呢？</strong></p>
<ol>
<li>所取得任何名字都可能于类得某个成员名称相冲突</li>
<li>调用构造器是编译器的责任，所以<strong>必须让编译器知道应该调用哪个方法。</strong></li>
</ol>
<p>解决方法：c++中采用的解决方案看起来最简单且更符合逻辑，Java也采用了这种方法，即构造器采用与类相同的名称。考虑到在初始化期间要自动调用构造器，这种做法就顺利成章了。</p>
<p>规定不接受任何参数的构造器叫做默认构造器(无参构造器)</p>
<p><strong>如果我们编写的类不包含构造器，那么编译器会自动帮你创建一个默认构造器。</strong></p>
<p><strong>但是如果你构造了一个构造器，那么无论是否定义了一个构造器，编译器就不会再帮你自动创建默认构造器。</strong></p>
<blockquote>
<p>尽管没有显式地使用static关键字，构造器实际上也是静态方法。</p>
</blockquote>
<p>而通过构造器形式参数，就可以在初始化对象时提供实际参数。</p>
<p>从概念上讲，“初始化”和“创建”是彼此独立的，在Java中，“初始化”和“创建”是捆绑在一起的，二者不能分离。（Class文件中new指令之后执行()方法）</p>
<h2><strong>方法重载(Overload)</strong></h2>
<p>在了解了对象的初始化之后，我们继续考虑类中的方法(属性暂时不讨论)。对象可调用的方法就是对对象数据的一系列操作。</p>
<p>任何程序设计语言都具备的一项重要特性就是对名字的运用。</p>
<p>对象就是给此对象分配到的存储空间取了一个名字。</p>
<p>所谓方法就是给某个动作取的名字。</p>
<p><strong>在Java中，构造器是强制重载方法名的另一个原因，既然构造器的名字已经由类名所决定，就只能有一个构造器名，要想用多种方式初始化一个对象该怎么办呢？</strong></p>
<p><strong>多种方式初始化对象，而这些方式毫无疑问都是构造器，因此它们又有相同的名字，即类名。为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载。同时，尽管方法重载是构造器所必须的，但它亦可应用于其他方法。</strong></p>
<p>想使用多种方式初始化对象的思路提出来了，使用方法重载，方法名相同，形参不同，那么问题是，<strong>如何在初始化的时候正确的调用相应的操作呢？</strong></p>
<p>其实这个问题相当于是要求我们知道，对于重载的方法，编译器是如何将它们区分开来的呢？</p>
<p>使用哪个重载版本，完全取决于传入参数的数量和数据类型。虚拟机在重载时是通过参数的静态类型而不是实际类型作为判定依据的。</p>
<p>静态分派---重载</p>
<h2><strong>零星知识点</strong></h2>
<h3><strong>关键字</strong></h3>
<h3><strong>this关键字</strong></h3>
<ol>
<li>如果我们希望在方法内部获得对当前对象的引用，由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是为此有个专门的关键字：<strong>this</strong>,this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。</li>
<li>在构造器中调用构造器。为一个类编写多个构造器，有时可能想在一个构造器中调用另一个构造器，利用this可做到这一点。在构造器中，若为this添加了参数列表<code class="notranslate">this(a,b,c)</code>，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用。</li>
<li>可避免产生歧义<code class="notranslate">this.name = name</code></li>
</ol>
<h3><strong>Static关键字</strong></h3>
<p>前面的this关键字，为当前对象的引用，现在介绍一下static</p>
<ol>
<li>static就是没有this的方法。在static方法的内部不能调用非静态方法，反过来是可以的</li>
<li>在没有创建对象时的前提下，仅仅通过类本身调用static方法。</li>
<li>使用static时，由于不存在this因此不是通过向对象发送消息的方式来完成的，然而无论如何，static的概念的确有其实用之处。</li>
</ol>
<blockquote>
<p>代码块主要分三种，Static静态代码块，构造代码块，普通代码块，代码块执行顺序：静态代码块，构造代码块，构造函数，普通代码块</p>
</blockquote>
<h3><strong>final关键字</strong></h3>
<p>final关键字的出现通常意味着，这是无法改变的。</p>
<h3><strong>final数据</strong></h3>
<ol>
<li>在对final修饰的常量（基本数据类型）进行定义时，必须对其进行赋值。</li>
<li>当对对象引用使用final时，final使引用恒定不变。一旦引用被初始化指向一个对象就无法再把它改为指向另一个对象。然而，对象其自身却可以被修改，Java并未提供使任何对象恒定不变的途径。</li>
</ol>
<h3><strong>final方法</strong></h3>
<p>第一个原因是把方法锁定，以防止继承类修改它的含义，这是出于设计的考虑，想确保在继承中使方法行为保持不变，而且不会被覆盖。</p>
<h3><strong>final和private关键字</strong></h3>
<ul>
<li>**类中所有的private都隐式地指定为final的。由于无法取用private方法，所以也就无法覆盖他。**可以对private方法添加final修饰词，但这并不能给该方法增加任何额外的意义。</li>
</ul>
<h3><strong>final类</strong></h3>
<p>当将某个类的整体定义为final时，就表明了你不打算继承该类，而且也不允许别人做么做。换句话说，我们对该类的设计永不需要做任何变动。或出于安全的考虑，你不希望它有子类。</p>
<p>此处不对垃圾回收做介绍</p>
<h3><strong>静态数据的初始化</strong></h3>
<p>无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，没有对他进行初始化，那么他就会获得基本类型的标准初值，如果是一个对象引用，那么它的默认初始化值就是null</p>
<p>Java允许将多个静态初始化动作组织成一个特殊的“静态子句(静态块)”，与其他静态初始化动作一样，这段代码仅执行一次：当首次生成这个类的第一个对象时，或者首次访问属于那个类的静态数据成员时。</p>
<h2><strong>访问控制权限</strong></h2>
<h3><strong>关于package和import</strong></h3>
<ol>
<li>包机制
<ul>
<li>package为了方便程序的管理，不同功能的类被分门别类放到不同的软件包中，查找，管理比较方便，易维护。</li>
<li>Java为了更好的组织类，提供了包机制，用于区分类名的命名空间。用c语言开发项目，当代码量过多时，会出现问题，名称会发生冲突，而对于Java，关键字package，包的命名模式，和关键字import，可以使对名称进行完全控制，避免名称冲突。</li>
<li>包的作用：
<ul>
<li>将功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
</li>
</ul>
</li>
<li>import导入其他类，同一个包下的类不需要导入。</li>
</ol>
<h3><strong>Java访问权限修饰词</strong></h3>
<p>控制对成员的访问权限是因为为了使用户不要触碰它们不该触碰的部分，这部分对于类内部的操作是必要的，但是不属于客户端程序员所需接口的一部分。第二个原因是，为了让类库设计者可以更改类的内部工作方式，而不必担心这样会对客户端程序员产生与大影响。</p>
<p>public：接口访问权限</p>
<p>private：你无法访问</p>
<p>protected：继承访问权限（包含包访问权限）</p>
<p>default：包访问权限</p>
<h2><strong>类与类的关系</strong></h2>
<p>在基本了解类和对象之后，我们能够识别并设计一个类。直到此，依然是单个的类或对象，那么运用OOD解决问题时，定然不止一个类，那么多个类之间又有什么样的关系呢？</p>
<p>常见关系有：<strong>依赖(uses-a)，聚合(has-a)，继承(is-a)</strong></p>
<p><strong>uses-a</strong>:一个类的方法操纵另一个类的对象，应当降低类间的依赖，降低类的耦合度</p>
<p>**has-a:**意味着类A的对象包含类B的对象</p>
<p>**is-a:**继承，即is-a，是一种用于表示特殊和一般关系的</p>
<h3><strong>封装(Encapsulation)</strong></h3>
<p>在面向对象编程中，封装是指</p>
<p><strong>数据和方法包装进类中，以及抽象性函数接口的具体实现的隐藏，常共同被称作是封装</strong></p>
<p>数据和操作数据的方法绑在一起，提供了便利性，侧重点是封装的后半句话，<strong>抽象性函数接口具体实现的隐藏(data hiding)</strong>，为什么要隐藏具体实现，因为对于访问该类的对象，我们只需要提供供其他对象使用的接口即可，并不需要他们了解其背后如何实现，从而降低耦合度和提高健壮性。</p>
<p>那么为了告诉哪些是给你提供的接口，通过访问修饰词来提示访问该类的对象哪些是可用的接口。</p>
<blockquote>
<p>这里我们因该注意的时，这里的接口指的是提供给使用该类库工作的客户的，而与Java语法的interface接口是不同的。</p>
</blockquote>
<p>不仅如此，通过这样的设计之后，类库的设计者可以对类库的代码进行修改，使用该类的用户无需改动其代码。</p>
<p>出于这两个很重要的原因，访问权限控制将权限的边界划在了数据类型的内部。</p>
<ol>
<li>第一个原因是要设定客户端程序员可以使用和不可以使用的界限。可以在结构中建立自己的内部机制，而不必担心客户端程序员会偶然将内部机制当作他们可以使用的接口的一部分。</li>
<li>将接口和具体实现进行分离。如果结构是用于一组程序之中，而客户端程序员除了可以向接口发送信息之外什么也不做的话，那么就可以随意更改所有不是public的东西，而不会破坏客户端代码。</li>
</ol>
<p>**对象不需要公开它的所有属性和行为。在好的OO设计中，对象只应公开其他对象与之交互所必须的接口。与对象使用无关的细节应当对其他对象隐藏。**封装定义为对象同时包含属性和行为。数据隐藏(data hiding，包含属性和行为)则是封装的一个主要部分。类库设计者通过访问控制权限词来控制向客户开放的权限或接口。</p>
<ul>
<li>
<p>实现封装的基础--接口(此接口非彼接口)</p>
<ul>
<li>接口定义了对象间通信的基本途径。比如你想开车，那么车和你是两个不同的对象，车“封装”之后对其他对象保留了一些必要的接口--方向盘，刹车，油门，离合，通过这几个接口就可以使用车。</li>
<li>接口应当全面描述这个类的用户如何与类交互，在大多数OO语言中，接口中的方法都指定为public，因为接口本就是要面向客户的。</li>
<li>私有数据--要实现数据隐藏，所有属性都应该声明为private，因此属性不是接口的一部分。将属性声明为public会破坏数据隐藏的概念。</li>
<li>只有公共属性和方法被认为是接口，用户不应该看到任何实现部分。</li>
</ul>
<p>看到这里其实就应该了解到对于一个类的封装设计，保留了与其他对象信息交流的接口，然而具体的内部实现则为对象的私有内容。你的电脑最后1%的电，需要充电，那么就需要把充电线插到电源插座上，电源的具体实现是发电厂的电，还是柴油机的电，都无需你去关心。仔细想一想不就是<strong>请求对象</strong>需要某个对象的数据，再调用该对象提供的<strong>接口</strong>，获取你想要的<strong>数据(返回值)</strong>。通过这种通信方式，当我们需要修改内部的函数时，而无需修改接口，这一点带来的健壮性便原声面向过程。</p>
</li>
</ul>
<p>简单来说，OO设计通过封装，使得每个对象成为独立的个体，每一个对象都有与其他对象进行的接口，也有自己不对外可见的私有内容。封装提高了模块内部的内聚程度，模块内部的各小模块相互独立，各模块都保留对外开放的接口。</p>
<h3><strong>继承</strong></h3>
<p>好吧，封装介绍之后，还是来到了继承。</p>
<p>OO程序设计中最强大的一个特性就是代码重用。<strong>结构化设计从某种程度上提供了代码重用--我们可以编写一个函数(结构化设计中函数的本质就是过程)，然后根据需要使用(调用)多次。不过OO设计则更进一步，允许组织类并抽取各个类的共性来定义类之间的关系，这不仅有利于代码的重用，还可以更好的整体设计</strong>。</p>
<p>这里我们介绍一些已经了解的内容：</p>
<ul>
<li>继承允许类继承另一个类 的属性和方法。这就允许通过抽取共同的属性和行为来创建全新的类。</li>
<li>超类和子类
<ul>
<li><strong>超类(OR父类)包含继承自该类的所有子类共有的属性和行为</strong>。例如<strong>所有的哺乳动物都有类似的属性，所以没必要在继承树中对每一种哺乳动物都重复定义这些属性和行为，重复不仅需要做更多的动作，可能更加麻烦而且还可能会招致错误和不一致</strong>。all in all,继承可以带来很多设计上的好处。设计一个Cat类时，Mammal类提供了很多所需的功能。通过继承Mammal对象，Cat已经具备使之成为一个哺乳动物的所有属性和行为。为了使它称为更具体的猫，Cat类必须包含猫所特有的属性和行为(即扩展)。</li>
</ul>
</li>
<li>抽象
<ul>
<li>继承树可能会扩展的相当庞大。完成了Mammal和Cat类后，就能很容易的增加其他哺乳动物，如Dog，bear。Cat还可以作为其他类的超类。<strong>继承的强大之处就在于其抽象和组织技术</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>需要提一点的是继承是is-a关系-------Dog is a animal</p>
</blockquote>
<p>在使用继承时，由于导出类具有基类接口，因此它可以向上转型至基类，这对多态来讲至关重要。</p>
<p>继承在不同语言分<strong>单重继承(single-inheritance)</strong>，<strong>多重继承(multiple-inheritance)</strong>。</p>
<h3><strong>抽象类和抽象方法</strong></h3>
<p>第一个问题，抽象类是什么？抽象类是abstrac声明的类，它可能不包含抽象方法，但他们可以被子类实例化。</p>
<p>第二个问题，什么是抽象方法？即只提供声明，不提供定义的方法。</p>
<p>第三个问题，抽象类用来干嘛？<strong>抽象类是为了继承而生的，是由子类具有相同的一类特征抽象而来，也可以说是其基类或父类。为什么这样说，因为抽象类的初衷是<code class="notranslate">抽象</code>,即规定这个类的型，具体实现还不确定，是不完整的，故也不允许直接创建实例。</strong></p>
<p><strong>那么既然抽象类就是子类共同特征的抽象，抽象类中的方法具体实现在子类，那么就要求抽象类的方法必须为public或protected，默认情况为public。</strong></p>
<p>Java提供了一个较抽象方法的机制，这种方法是不完整的，仅有声明而没有方法体<code class="notranslate">abstract void f();</code></p>
<p>抽象方法充当占位的角色，它们的具体实现在子类中，扩展抽象类可以有两种选择</p>
<p><strong>包含抽象方法的类叫抽象类，如果一个类包含抽象方法，那么这个类就必须设定为抽象类。如果从一个抽象类继承，并想创建该新类的对象，那么就必须要为基类中的所有抽象方法提供方法实现，如果不这样做，那么导出类便也是抽象类，且编译器会强制我们用abstract关键字来限定这个类。</strong></p>
<p>创建抽象类和抽象方法非常有用，因为他们可以使类的抽象性明确起来，并可以告诉用户和编译器打算怎样来使用它们，抽象类还是非常有用的重构工具，因为他们使得我们可以很容易的将公共方法沿着继承层次结构向上移动。</p>
<h3><strong>接口（注意区分接口在不同情况下所指的意义）</strong></h3>
<p>我们知道继承有单继承和多继承，Java不支持多继承是为了避免多重继承状态的问题，这是从多个类继承字段的能力。因为接口中不含有字段，所以不必担心多重状态继承导致的问题。</p>
<p><strong>Java编程语言支持类型的多重继承，这是一个类实现多个接口的能力。一个对象可以有多种类型：他自己的类的类型和类所实现的所有接口的类型。这意味着如果一个变量被声明为接口的类型，那么它的值可以引用任何实现了接口的类的实例化的对象。与实现的多重继承一样，一个类可以继承它所扩展的接口中定义的方法的不同实现。</strong></p>
<p>interface关键字使抽象的概念更进一步。但是要注意，接口不是类。interface关键字允许人们在类中创建一个或多个没有任何定义的方法--提供了接口的部分，但没有提供具体的实现。这些实现是由此类的继承者创建的。interface这个关键字产生一个完全抽象的类，他根本就没有提供任何具体的实现。它允许创建者确定方法名，参数列表，返回类型，的那没有任何方法体，接口只提供了形式，不提供任何具体实现。</p>
<p>接口不仅仅是一个极度抽象类似于类的东西，因为它允许通过创建能够向上转型为多种基类的类型，来实现某种类似多重继承的特性。</p>
<p>在Java中，接口是一种引用类型，类似于类，它只能包含<strong>常量，方法签名，默认方法，静态方法和嵌套类型</strong>。具有实现的唯一方法是默认和静态方法。接口无法实例化，它们只能由类实现或有其他接口扩展。</p>
<h3><strong>组合</strong></h3>
<p>组合可以很自然的认为对象包含其他对象。</p>
<p>对象通常是由其他对象构造或组合而成的，这就是组合(composition)</p>
<ul>
<li>
<p>抽象</p>
<p>和继承一样，组合提供了一种构建对象的机制。</p>
<p><strong>实际上，需要指出，基于其他类来构建类只有两种方法：继承和组合</strong>。</p>
<p>继承允许一个类从另一个类进程，这样能为公共类抽取出属性和行为。</p>
</li>
<li>
<p>利用组合可以通过在其他类中嵌入类来完成类的构建</p>
<p>考虑车和发动机之间的关系。将发动机和汽车分开的好处很明显。通过单独的构建发动机，可以在不同汽车中使用这个发动机。</p>
<p><strong>BUT</strong>不能说发动机是一个汽车（is-a关系），这听上去离了个大谱，要使用has-a来描述组合关系。一个汽车有一个发动机（has-a）关系。</p>
</li>
</ul>
<p><strong>has-a与is-a</strong></p>
<p>尽管继承关系被认为是is-a关系，但组合关系被称为has-a关系。</p>
<h3><strong>组合与继承</strong></h3>
<p>继承和组合在面向对象系统设计中占有重要的地位，实际上，许多最困难，最有意思的设计决策就是在继承和组合间做出选择。继承是一种父子关系，而组合是一种组装的关系。</p>
<p>继承和组装的存在最主要的原因是对象重用，实际上，要重用原先构造的类，只能通过继承和组合这两种途径。组合和继承都是合理的类设计技术，它们在OO开发人员的工具箱里都有其适当的地位。继承经常被误用和滥用，这往往是缺乏对继承的理解，而不是因为使用继承作为一种设计策略存在本质的缺陷。</p>
<p>最根本的是，继承和组合都是构建OO系统的重要技术。只是设计人员和开发人员需要花时间来了解这两种技术的优点和缺点，并在合适的情况下正确加以使用。</p>
<p><strong>继承的思想是通过抽取共性实现从一般到特殊</strong>。</p>
<blockquote>
<p>小结:很多知名的OO设计人员指出：应该尽可能地使用组合，而只在必要情况下才使用继承。尽管更多情况下使用组合比使用继承更合适，但不能绝对地说尽可能使用组合。组合大多数情况下都比继承更适用，不过这不意味着继承一无是处。组合和继承都可以使用，但只应在其适合的上下文中使用。</p>
</blockquote>
<h3><strong>继承会打破封装</strong></h3>
<p>为什么这样说，首先我们知道封装将属性和行为封装到对象中，并对外保留用于通信的接口，是将类打包到公共接口和私有实现的过程，实际上，类隐藏了不需要其他类知道的所有细节。</p>
<p>因此我们能够知道封装相对于别的对象给此对象”穿上了衣服“，别的对象看不到该对象的”身体“。而**使用继承时，类层次接口中的封装本质上会被削弱。**之所以这样说是因为尽管继承意味着与其他类的强封装，但超类与其子类之间的疯转会被削弱。</p>
<p>问题在于如果从一个超类继承一个实现，然后需改这个实现，那么超类的修改会对整个类层次结构产生涟漪作用。这种涟漪效应可能会影响所有子类。什么意思呢？如果创建一个名为Cabbie的类，并有适当的公共接口，则对Cabbie实现的任何修改都应当对所有其他类<strong>透明</strong>（隐身），不过任何设计中，对超类的修改肯定不对子类透明。</p>
<h3><strong>多态</strong></h3>
<p>提及继承自然离不开多态。多态--polymorphism是一个希腊词语，字面意思是多种形状。尽管多态和继承紧密相连，但通常被单独视为面向对象技术最强大的一个优点。</p>
<p>多态是为了消除类型之间的耦合关系</p>
<p>在继承层次结构中，所有子类都从其超类继承<strong>接口</strong>，不过由于每个子类都是一个单独的实体，<strong>它们可能需要对同一个消息做出不同的响应</strong>。例如Shape类和行为Draw。要求某人画一个形状，他会问画什么图形，没有人能画出一个形状，因为这是一个抽象的概念。必须指定一个具体的形状。为此需要在Circle类中提供具体的实现。尽管Shape有一个Draw方法，但Circle覆盖了这个方法，并提供了自己的Draw()方法。<strong>覆盖overriding</strong>实际上是指将父类的一个实现替换为其子类的一个实现。</p>
<blockquote>
<p>这里引入了构造函数，构造函数与其所在类同名，而且没有任何返回类型。可以将构造函数认为是类的入口点，对象由此构建。构造函数非常适合完成初始化和准备工作。</p>
</blockquote>
<p>继承允许将对象视为它自己本身的类型或其基类型来加以处理，这种能力极为重要，因为它允许将多种类型(从同一基类导出的)视为同一类型来处理，而同一份代码也就可以毫无差别的运行在不同类型上了。</p>
<p><strong>我们将把对某个对象的引用视为对其基类型的引用的做法被称为向上转型</strong></p>
<p><strong>所发生的具体行为取决于子类的类型</strong></p>
<h3><strong>方法覆盖</strong></h3>
<p>多态和继承体系有关，与方法覆盖有关，与方法重载无关。</p>
<p>方法覆盖即为，父类引用指向子类对象时，调用子类的方法而不调用父类方法。</p>
<h3><strong>多态是一个详细的例子</strong></h3>
<p>很多人认为多态是<code class="notranslate">OO</code>设计的一个基石。</p>
<p>设计一个类来创建完全独立的对象，这就是<code class="notranslate">OO</code>的主要内容。在一个良好的系统中，<strong>对象应该能回答有关他的所有重要问题(想一想什么意思)</strong>。</p>
<p><code class="notranslate">在编程时，我们希望能够减少些工作量，如果我们需要针对各导出类都编写一个类似的方法，这不是一个小的工作量，繁琐，因此我们是不是可以只写一个这样的方法，它仅接受基类作为参数，而非导出类，也就是说，我们希望编写的代码只跟基类打交道。</code></p>
<p><code class="notranslate">那么如果这个方法只接受基类，那么又如何判断这个引用指向的到底时那个对象？编译器无法得知，下面就涉及方法绑定的话题</code></p>
<ol>
<li>将一个方法调用同一个方法主体关联起来称作绑定，如果在程序执行前绑定称为前期绑定</li>
<li>在运行时根据对象的类型进行绑定，称为后期绑定或动态绑定或运行时绑定</li>
</ol>
<p>如果一种语言想实现后期绑定，就必须具有某种机制，以便<strong>在运行时能判断对象的类型，从而调用恰当的方法。</strong></p>
<blockquote>
<p>Java中除了static和final方法之外，其他所有方法都是后期绑定。</p>
<p>将某个方法声明为final，可以防止其他人覆盖该方法，但更重要的一点或许是：这样做能有效关闭动态绑定，或者说，告诉编译器不需要对其进行动态绑定。</p>
</blockquote>
<p>这正是多态所允许的。</p>
<p>通常对象应当对自己负责,这种独立性正是代码重用的主要机制之一。</p>
<p>多态的原则是，可以向不同对象发送信息，它们会根据其对象的类型做出响应。</p></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer">Copyright © <span id="year"></span><a href="https://membrane-s.github.io"> BlueOrange's blog </a>
<p>
<span id="runday"></span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a>
</p>

<script>
if(""!=""){
    var now=new Date();
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("year").innerHTML=now.getFullYear();
    if(""!=""){document.getElementById("runday").innerHTML=" • "+"网站运行"+diffDay+"天"+" • ";}
    else{document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";}
}
</script>
</div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n\n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","membrane-s/membrane-s.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>


</html>
